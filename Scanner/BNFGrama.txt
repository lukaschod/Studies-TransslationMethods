/*************************************************************************
 * 
 * BNF Gramma of Void Language
 * __________________
 * 
 *  09/23/2017
 *  By Lukas Chodosevicius
 * 
 * This is the BNF gramma of 'C language.
 * This language is based on C\C++ just a small part of it for learning purpose
 */

//------------------------- Program ----------------------
<program>           ::= <lanesDeclare>
<lanesDeclare>      ::= <laneDeclare> 'end' | <laneDeclare> <lanesDeclare>
<laneDeclare>       ::= <moduleDeclare> | <functionDeclare> | <veriableDeclare> | <classDeclare>

//--------------------------- Characters --------------------------
<digits>       ::=     <digit> <digits> | <digit>
<digit>        ::=     '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

<letters>      ::=     <letter> <letters> | <letter>
<letter>       ::=     'a' | 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z'

<symbols>      ::=     <symbol> <symbols> | <symbol>
<symbol>       ::=     '_' 

<texts>        ::=     <text> <texts> | <text>
<text>         ::=     <letter> | <digit> | <symbol>

<name>         ::=     <letter> <texts> | <symbol> <texts>

<seperator>    ::=     ';'

//------------------------- Modules ----------------------
<moduleName>            ::= <name>

<moduleDeclare>         ::= 'module' <moduleName> <seperator>

//------------------------- Statements ---------------------
<block>              ::=     '{' '}' | '{' <statements>

<statements>         ::=     <statement> '}' | <statement> <statements>
<statement>          ::=     <statementDefault> | <statementCondition> | <statementControl> | <statementReturn>

<statementDefault>   ::=     <veriableDeclare> | <veriableChange> | <io> | <functionCall>
<statementControl>   ::=     <loopFor> | <loopWhile> | <statementCondition>
<statementCondition> ::=     'if' '(' <expression> ')' <block> | 'if' '(' <expression> ')' <block> 'else' <block>
<statementReturn>    ::=     'return' <expression> <seperator>

// ---------------------- In Out -----------------
// This is mostly as example, because at some point it would be just library not some hard coded print write
<io>         ::=     <input> | <output>
<input>      ::=     'scan' '(' <expression> ')' <seperator>
<output>     ::=     'print' '(' <expression> ')' <seperator>

//---------------------- Loops ----------------
<loopFor>         ::=     'for' '(' <expression> ';' <expression>' ';' <expression> ')' <block>
<loopWhile>       ::=     'while' '(' <expression> ')' <block>

//------------------------- Veriables ----------------------
<veriableName>         ::=    <name>

<veriableDeclare>      ::=    <typeNameFull> <veriableName> <seperator> | <typeNameFull> <veriableName> '=' <expression> <seperator>
<veriableChange>       ::=    <expressionVeriable> <assigment> <expression> <seperator>

//------------------------- Functions ----------------------
<functionName>         ::=     <name>

<functionDeclare>      ::=     <typeNameFull> <functionName> '(' ')' <block> | <typeNameFull> <functionName> '(' <parametersDeclare> <block>
<parametersDeclare>    ::=     <parameterDeclare> ')' | <parameterDeclare> ',' <parametersDeclare>
<parameterDeclare>     ::=     <typeNameFull> <veriableName>

<functionCall>         ::=     <functionName> '(' <parametersCall> | <functionName> '(' ')'
<parametersCall>       ::=     <expression> ')' | <expression> ',' <parametersCall>

//------------------------- Class ----------------------
<className>      ::=     <name>
<classNameFull>  ::=     <className> | <className> <postfixs> | <prefixs> <className> <postfixs> | <prefixs> <className>

<classDeclare>          ::=     'class' <className> '{' '}' | 'class' <className> '{' <classLanesDeclare> 
<classLanesDeclare>     ::=     <classLaneDeclare> '}' | <classLaneDeclare> <classLanesDeclare>
<classLaneDeclare>      ::=     <methodDeclare> | <memberDeclare>
<accesabilityName>      ::=     'private' | 'public' | 'protected'

<memberDeclare>         ::=     <accesabilityName> <veriableDeclare>

<methodDeclare>         ::=     <accesabilityName> <methodDefaultDeclare>
//<methodCtorDeclare>     ::=     <functionName> '(' <parametersDeclare> ')' <block> | <functionName> '(' ')' <block>
//<methodDtorDeclare>     ::=     '~' <functionName> '(' <parametersDeclare> ')' <block> | '~' <functionName> '(' ')' <block>
<methodDefaultDeclare>  ::=     <functionDeclare>

--------------------------- Types --------------------------
<constantInt>            ::=     <digits>
<constantFloat>          ::=     <constantInt> '.' <constantInt>
<constantBoolean>        ::=     'true' | 'false'
<constantString>         ::=     '"' <texts> '"'
<constant>       ::=     <constantInt> | <constantFloat> | <constantBoolean> | <constantString>

<prefixs>        ::=     <prefix>
<prefix>         ::=     'const'
<postfixs>       ::=     <postfix> <postfixs> | <postfix>
<postfix>        ::=     '*' | '&' | '[' <constantInt> ']'

<primitiveName>          ::=     'int' | 'float' | 'string' | 'bool' | 'void'
<primitiveNameFull>      ::=     <primitiveName> | <primitiveName> <postfixs> | <prefixs> <primitiveName> <postfixs> | <prefixs> <primitiveName>

<typeNameFull>           ::=     <classNameFull> | <primitiveNameFull>

//------------------------ Expressions --------------------
<and>          ::=     '&&'
<or>           ::=     '||'
<comparison>   ::=     '<' | '<' '=' | '>' | '>' '=' | '!' '=' | '=' '='
<add>          ::=     '+' | '-'
<mult>         ::=     '*' | '/' | '>>' | '<<' | '%'
<assigment>    ::=     '=' | '-=' | '+=' | '*='
<singleOp>     ::=     '!' | '-' | '^' | '~' | '*' | '&'

<expression>      ::=     <expressionAnd> <or> <expression> | <expressionAnd>
<expressionAnd>   ::=     <expressionCmp> <and> <expressionAnd> | <expressionCmp> 
<expressionCmp>   ::=     <expressionAdd> <comparison> <expressionCmp> | <expressionAdd>
<expressionAdd>   ::=     <expressionMult> <add> <expressionAdd> | <expressionMult>
<expressionMult>  ::=     <expressionUno> <mult> <expressionMult> | <expressionUno>
<expressionUno>   ::=     <expressionVeriable> | <constant> | '(' <expression> ')'

<expressionVeriable>      ::= <expressionVeriableItem> | <expressionVeriableItem> '.' <expressionVeriable>
<expressionVeriableItem>  ::= <veriableName> | <functionCall> | <veriableName> <expressionVeriableArray> | <functionCall> <expressionVeriableArray>
<expressionVeriableArray> ::= '[' <expression> ']' | <expressionVeriableArray> '[' <expression> ']'

// ------------------- Example ----------------
/*
use Windows.System

// Linear Congruential Generator
class Random
{
	private int state;

	public Random(int seed)
	{
		state = seed;
	}

	public int GetNext()
	{
		state = state * 1664525 + 1013904223;
   		return state >> 24;
	}
}

void Printf(int message)
{
	print(message);
}

void Printf(string message)
{
	print(message);
}

void Main()
{
	Printf("Hello World!");

	Printf("Printing random numbers with state 5");
	Random random = Random(5);
	for (int i = 0; i < 10; i+=1)
	{
		Printf(random.GetNext());
		a.b.d.c = y.j.k;
	}
	if () {}
}
*/